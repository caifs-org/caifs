#!/bin/sh

BINDIR=$(dirname "$0")
. "${BINDIR}"/../lib/caifslib.sh

RUN_TARGETS=""
RUN_LINKS=${CAIFS_RUN_LINKS:-0}
RUN_HOOKS=${CAIFS_RUN_HOOKS:-0}
HOOKS_DIR=hooks


print_help() {
    cat << 'EOF'
Usage: caifs [--verbose] [--help] [--version] <command> [options] <targets...>

Config And Installers For Software - a cross-platform dotfile manager and installer.

Commands:
  add <targets...>    Run hooks and create symlinks for targets (alias: run)
  rm <targets...>     Remove symlinks and run removal hooks for targets
  status              Show link status of all targets in collections

Add Command options:
  -d, --directory <path>  Collection directory (can be specified multiple times)
  -l, --links             Only create symlinks, skip hooks
  -h, --hooks             Only run hooks, skip symlinks
  -f, --force             Overwrite existing files/links
  -n, --dry-run           Don't do any linking or run hooks, just print the action
  -r, --link-root <path>  Set an alternative to $HOME as the link destination

Remove Command options:
  -d, --directory <path>  Collection directory (can be specified multiple times)
  -l, --links             Only remove symlinks, skip rm hooks
  -h, --hooks             Only run rm hooks, skip symlink removal
  -n, --dry-run           Don't do any linking or run hooks, just print the action
  -r, --link-root <path>  Set an alternative to $HOME as the link destination

Status Command options:
  -d, --directory <path>  Collection directory (can be specified multiple times)
  -r, --link-root <path>  Set an alternative to $HOME as the link destination

Global options:
  -v, --verbose           Enable debug output
  -h, --help              Show this help message
  --version               Show version number and exit

Environment variables:
  CAIFS_COLLECTIONS       Colon-separated list of collection paths (default: $PWD)
  CAIFS_LINK_ROOT         Destination root for symlinks (default: $HOME)
  CAIFS_VERBOSE           Set to 0 to enable debug output
  CAIFS_RUN_FORCE         Set to 0 to force overwrite existing files/links
  CAIFS_RUN_LINKS         Set to 1 to skip symlinking
  CAIFS_RUN_HOOKS         Set to 1 to skip hooks

Examples:
  caifs add git                       Run git target from current directory
  caifs add git bash -d ~/dotfiles    Run multiple targets from specified collection
  caifs add nvim --links              Only symlink nvim configs, skip hooks
  caifs add docker --hooks            Only run docker hooks, skip symlinks
  caifs add bash --force              Overwrite existing bash config files
  caifs rm git -d ~/dotfiles --links  Remove symlinks for git target
  caifs status -d ~/dotfiles          Show link status for all targets
EOF
}

main() {
    log_debug "Parsing Arguments $*"

    if [ $# -eq 0 ]; then
        print_help
        exit 1
    fi

    SUBCOMMAND=$1
    shift

    if [ "$SUBCOMMAND" = "--verbose" ] || [ "$SUBCOMMAND" = "-v" ]; then
        VERBOSE=0;
        if [ $# -eq 0 ]; then
            print_help
            exit 1
        fi
        SUBCOMMAND=$1
        shift
    fi
    if [ "$SUBCOMMAND" = "--dry-run" ] || [ "$SUBCOMMAND" = "-n" ]; then
        DRY_RUN=0
        SUBCOMMAND=$1
        shift
    fi
    if [ "$SUBCOMMAND" = "--help" ] || [ "$SUBCOMMAND" = "-h" ]; then
        print_help
        exit 0
    fi
    if [ "$SUBCOMMAND" = "--version" ]; then
        echo "$VERSION"
        exit 0
    fi

    case "$SUBCOMMAND" in
        add)
            # Parse 'run' specific options
            SUB_TEMP=$(getopt -o r:nflhd: -l link-root:,dry-run,force,links,hooks,directory: -n "run" -- "$@")
            # shellcheck disable=SC2181
            if [ $? -ne 0 ]; then exit 1; fi
            eval set -- "$SUB_TEMP"

            ARG_CAIFS_COLLECTIONS=""
            while true; do
                case "$1" in
                    -l|--links) RUN_HOOKS=1; shift ;;
                    -h|--hooks) RUN_LINKS=1; shift ;;
                    # If directory is specified, override any collection paths and just work with this directory
                    -d|--directory)
                        if [ -n "$ARG_CAIFS_COLLECTIONS" ]; then
                            ARG_CAIFS_COLLECTIONS="${ARG_CAIFS_COLLECTIONS}:$(realpath "$2")"
                        else
                            ARG_CAIFS_COLLECTIONS=$(realpath "$2")
                        fi
                        shift 2
                        ;;
                    -n|--dry-run) DRY_RUN=0; shift ;;
                    -r|--link-root) LINK_ROOT=$(realpath "$2"); shift 2;;
                    -f|--force) RUN_FORCE=0; shift ;;
                    --) shift; break ;;
                    *) break ;;
                esac
            done

            # All directories have been parsed, so override any pre-set CAIFS_COLLECTIONS entries
            if [ -n "$ARG_CAIFS_COLLECTIONS" ]; then
                CAIFS_COLLECTIONS=$ARG_CAIFS_COLLECTIONS
            fi
            RUN_TARGETS="$*"

            log_debug "$RUN_TARGETS"
            if [ -z "$RUN_TARGETS" ]; then
                echo "At least one target is required!"
                exit 1
            fi

            log_debug "$SUBCOMMAND RUN_TARGETS=$RUN_TARGETS | VERBOSE=$VERBOSE RUN_LINKS=$RUN_LINKS RUN_HOOKS=$RUN_HOOKS ROOT_DIRECTORY CAIFS_COLLECTIONS=$CAIFS_COLLECTIONS"
            cmd_add
            ;;
        rm)
            SUB_TEMP=$(getopt -o r:nlhd: -l link-root:,dry-run,links,hooks,directory: -n "rm" -- "$@")
            # shellcheck disable=SC2181
            if [ $? -ne 0 ]; then exit 1; fi
            eval set -- "$SUB_TEMP"

            ARG_CAIFS_COLLECTIONS=""
            while true; do
                case "$1" in
                    -d|--directory)
                        if [ -n "$ARG_CAIFS_COLLECTIONS" ]; then
                            ARG_CAIFS_COLLECTIONS="${ARG_CAIFS_COLLECTIONS}:$(realpath "$2")"
                        else
                            ARG_CAIFS_COLLECTIONS=$(realpath "$2")
                        fi
                        shift 2
                        ;;
                    -l|--links) RUN_HOOKS=1; shift ;;
                    -h|--hooks) RUN_LINKS=1; shift ;;
                    -n|--dry-run) DRY_RUN=0; shift ;;
                    -r|--link-root) LINK_ROOT=$(realpath "$2"); shift 2;;
                    --) shift; break ;;
                    *) break ;;
                esac
            done

            # All directories have been parsed, so override any pre-set CAIFS_COLLECTIONS entries
            if [ -n "$ARG_CAIFS_COLLECTIONS" ]; then
                CAIFS_COLLECTIONS=$ARG_CAIFS_COLLECTIONS
            fi
            RUN_TARGETS="$*"

            log_debug "$SUBCOMMAND CAIFS_COLLECTIONS=$CAIFS_COLLECTIONS RUN_TARGETS=$RUN_TARGETS"
            cmd_remove
            ;;
        status)
            SUB_TEMP=$(getopt -o r:d: -l link-root:,directory: -n "status" -- "$@")
            # shellcheck disable=SC2181
            if [ $? -ne 0 ]; then exit 1; fi
            eval set -- "$SUB_TEMP"

            ARG_CAIFS_COLLECTIONS=""
            while true; do
                case "$1" in
                    -d|--directory)
                        if [ -n "$ARG_CAIFS_COLLECTIONS" ]; then
                            ARG_CAIFS_COLLECTIONS="${ARG_CAIFS_COLLECTIONS}:$(realpath "$2")"
                        else
                            ARG_CAIFS_COLLECTIONS=$(realpath "$2")
                        fi
                        shift 2
                        ;;
                    -r|--link-root) LINK_ROOT=$(realpath "$2"); shift 2;;
                    --) shift; break ;;
                    *) break ;;
                esac
            done

            if [ -n "$ARG_CAIFS_COLLECTIONS" ]; then
                CAIFS_COLLECTIONS=$ARG_CAIFS_COLLECTIONS
            fi

            cmd_status
            ;;
        *)
            echo "Unknown subcommand: $SUBCOMMAND"
            echo ""
            print_help
            exit 1
            ;;
    esac
}


# Run a specific type of hook for a given target.
# The script is sourced to give access to all the caifs runtime variables.
# $1: collection path
# $2: target
# $3: hook type [pre|post|rm]
run_hook() {
    collection_path="$1"
    target=$2
    hook_type=$3
    log_debug "Running ${hook_type}-hook for target '$target' in collection $collection_path"

    if [ -f "$collection_path/$target/$HOOKS_DIR/${hook_type}.sh" ]; then
        TMP_DIR=$(mktemp -d)
        cd "${TMP_DIR}" || exit

        # shellcheck disable=SC1090
        # import the hook script functions
        . "$collection_path/$target/$HOOKS_DIR/${hook_type}.sh"

        run_hook_functions

        cd - || exit
        rm -rf "${TMP_DIR}"
    else
        log_debug "No ${hook_type}-hook found for target '$target'. Ignoring"
    fi
}

# $1: collection path
# $2: The target name to run the hook for
run_remove_hook() {
    run_hook "$@" "rm"
}

# $1: collection path
# $2: The target name to run the hook for
run_pre_hook() {
    run_hook "$@" "pre"
}

# $1: collection path
# $2: The target name to run the hook for
run_post_hook() {
    run_hook "$@" "post"
}


# command handler for running the remove action
# $1: target to action
cmd_remove() {
    log_debug "Removing $RUN_TARGETS from '$CAIFS_COLLECTIONS'"
    collection_paths="$CAIFS_COLLECTIONS"

    while [ -n "$collection_paths" ]; do
        caifs_collection="${collection_paths%%:*}"

        log_debug "Working with $caifs_collection"

        for target in $RUN_TARGETS; do
            log_debug "$target"

            if [ "$RUN_LINKS" -eq 0 ]; then
                remove_target_links "${caifs_collection}" "${target}" "${LINK_ROOT}"
            fi

            if [ "$RUN_HOOKS" -eq 0 ]; then
                run_remove_hook "${caifs_collection}" "$target"
            fi
        done
            # Loop control, get the next path to operate on
        if [ "$caifs_collection" = "$collection_paths" ]; then
            # No more paths available. End the loop
            collection_paths=""
        else
            collection_paths="${collection_paths#*"${caifs_collection}":}"
        fi
    done
}

# Loop over the CAIFS_COLLECTIONS variable, which is colon (:) separated paths to caifs collections
# First target wins, so order in the collection is important.
cmd_add() {
    log_debug "cmd_add: begin with collection_paths '$CAIFS_COLLECTIONS'"

    collection_paths="$CAIFS_COLLECTIONS"

    while [ -n "$collection_paths" ]; do

        caifs_collection="${collection_paths%%:*}"

        log_debug "Working with $caifs_collection"

        for target in $RUN_TARGETS; do
            log_debug "$target"

            if [ "$RUN_HOOKS" -eq 0 ]; then
                run_pre_hook "${caifs_collection}" "$target"
            fi

            if [ "$RUN_LINKS" -eq 0 ]; then
                create_target_links "${caifs_collection}" "${target}" "${LINK_ROOT}"
            fi

            if [ "$RUN_HOOKS" -eq 0 ]; then
                run_post_hook "${caifs_collection}" "$target"
            fi
        done

        # Loop control, get the next path to operate on
        if [ "$caifs_collection" = "$collection_paths" ]; then
            # No more paths available. End the loop
            collection_paths=""
        else
            collection_paths="${collection_paths#*"${caifs_collection}":}"
        fi
    done

    log_debug "cmd_add: end"
}

# Display status of all targets in collections
cmd_status() {
    log_debug "cmd_status: CAIFS_COLLECTIONS=$CAIFS_COLLECTIONS LINK_ROOT=$LINK_ROOT"

    collection_paths="$CAIFS_COLLECTIONS"

    # Detect unicode support, fallback to ASCII
    case "${LC_ALL:-${LC_CTYPE:-${LANG:-}}}" in
        *UTF-8*|*utf8*)
            CHECK="✓"; CROSS="✗"; DASH="-"
            ;;
        *)
            CHECK="Y"; CROSS="N"; DASH="-"
            ;;
    esac

    # Color codes for linked column (only if stdout is a terminal)
    if [ -t 1 ]; then
        GREEN='\033[0;32m'
        RED='\033[0;31m'
        NC='\033[0m'
    else
        GREEN=''; RED=''; NC=''
    fi

    # Print header
    printf "%-40s %-20s %-8s %s\n" "COLLECTION" "TARGET" "LINKED" "HOOKS"
    printf "%-40s %-20s %-8s %s\n" "$(printf '%0.s-' $(seq 1 40))" "$(printf '%0.s-' $(seq 1 20))" "------" "-----"

    while [ -n "$collection_paths" ]; do
        caifs_collection="${collection_paths%%:*}"
        collection_name=$(basename "$caifs_collection")

        log_debug "Checking collection: $caifs_collection"

        # Find all targets (directories containing config/ or hooks/ subdirectory)
        if [ -d "$caifs_collection" ]; then
            for target_dir in "$caifs_collection"/*/; do
                [ -d "$target_dir" ] || continue
                target=$(basename "$target_dir")

                log_debug "Checking if target_dir=$target_dir contains a valid structure"
                is_valid_caifs_structure "$target_dir" || continue

                # Check linked status (pad for alignment, color for linked column only)
                if has_config "$target_dir"; then
                    log_debug "target_dir=$target_dir has config files"
                    if is_target_linked "$caifs_collection" "$target" "$LINK_ROOT"; then
                        linked_status="${GREEN}${CHECK}${NC}       "
                    else
                        linked_status="${RED}${CROSS}${NC}       "
                    fi
                else
                    linked_status="${DASH}       "
                fi

                # Check hooks status (has hooks/*.sh files)
                if has_hooks "$target_dir"; then
                    log_debug "target_dir=$target_dir has hooks"
                    hooks_status="${CHECK}"
                else
                    hooks_status="${CROSS}"
                fi

                printf "%-40s %-20s %b %s\n" "$collection_name" "$target" "$linked_status" "$hooks_status"
            done
        fi

        # Loop control
        if [ "$caifs_collection" = "$collection_paths" ]; then
            collection_paths=""
        else
            collection_paths="${collection_paths#*"${caifs_collection}":}"
        fi
    done
}

main "$@"
