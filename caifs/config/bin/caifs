#!/bin/sh

BINDIR=$(dirname "$0")
. "${BINDIR}"/../lib/caifslib.sh

##
## Some globals. These can generally be overridden via environment variables with the CAIFS_ prefix
# By default, run both links and hooks
VERSION=1.0.0
RUN_LINKS=${CAIFS_RUN_LINKS:-0}
RUN_HOOKS=${CAIFS_RUN_HOOKS:-0}

# Force the override of existing link targets
export RUN_FORCE="${CAIFS_RUN_FORCE:-1}"

# Multiple targets could be specified. We will run them in order
RUN_TARGETS=""
VERBOSE=${CAIFS_VERBOSE:=1}
export DRY_RUN="${CAIFS_DRY_RUN:-1}"

# A list of directories to interogate for caifs collections
CAIFS_COLLECTIONS=${CAIFS_COLLECTIONS:=$PWD}
export CONFIG_DIR=config
HOOKS_DIR=hooks

# The root directory of where config should link to. By default it should be home, but for root scenarios
# this can be overridden
LINK_ROOT=${CAIFS_LINK_ROOT:-$HOME}

# Source the OS type and export the most useful for being available in executed scripts
export OS_TYPE=
OS_TYPE="$(uname -s)"

export OS_ID=""
export OS_VERSION_ID=""

export OS_ARCH=
OS_ARCH="$(uname -m)"

if [ "${OS_TYPE}" = "Linux" ]; then
    # shellcheck disable=SC1091
    . /etc/os-release
    OS_ID=${ID}
    OS_VERSION_ID=${VERSION_ID}

elif [ "${OS_TYPE}" = "Darwin" ]; then
    OS_ID=$(sw_vers -productName)
    OS_VERSION_ID=$(sw_vers -productVersion)
else
    log_error "Unsupported Operating System - $OS_TYPE"
fi


print_help() {
    cat << 'EOF'
Usage: caifs [--verbose] [--help] [--version] <command> [options] <targets...>

Config And Installers For Software - a cross-platform dotfile manager and installer.

Commands:
  add <targets...>    Run hooks and create symlinks for targets (alias: run)
  rm <targets...>     Remove symlinks and run removal hooks for targets
  status              Show link status of all targets in collections

Add Command options:
  -d, --directory <path>  Collection directory (can be specified multiple times)
  -l, --links             Only create symlinks, skip hooks
  -h, --hooks             Only run hooks, skip symlinks
  -f, --force             Overwrite existing files/links
  -n, --dry-run           Don't do any linking or run hooks, just print the action
  -r, --link-root <path>  Set an alternative to $HOME as the link destination

Remove Command options:
  -d, --directory <path>  Collection directory (can be specified multiple times)
  -l, --links             Only remove symlinks, skip rm hooks
  -h, --hooks             Only run rm hooks, skip symlink removal
  -n, --dry-run           Don't do any linking or run hooks, just print the action
  -r, --link-root <path>  Set an alternative to $HOME as the link destination

Status Command options:
  -d, --directory <path>  Collection directory (can be specified multiple times)
  -r, --link-root <path>  Set an alternative to $HOME as the link destination

Global options:
  -v, --verbose           Enable debug output
  -h, --help              Show this help message
  --version               Show version number and exit

Environment variables:
  CAIFS_COLLECTIONS       Colon-separated list of collection paths (default: $PWD)
  CAIFS_LINK_ROOT         Destination root for symlinks (default: $HOME)
  CAIFS_VERBOSE           Set to 0 to enable debug output
  CAIFS_RUN_FORCE         Set to 0 to force overwrite existing files/links
  CAIFS_RUN_LINKS         Set to 1 to skip symlinking
  CAIFS_RUN_HOOKS         Set to 1 to skip hooks

Examples:
  caifs add git                       Run git target from current directory
  caifs add git bash -d ~/dotfiles    Run multiple targets from specified collection
  caifs add nvim --links              Only symlink nvim configs, skip hooks
  caifs add docker --hooks            Only run docker hooks, skip symlinks
  caifs add bash --force              Overwrite existing bash config files
  caifs rm git -d ~/dotfiles --links  Remove symlinks for git target
  caifs status -d ~/dotfiles          Show link status for all targets
EOF
}

main() {
    log_debug "Parsing Arguments $*"

    if [ $# -eq 0 ]; then
        print_help
        exit 1
    fi

    SUBCOMMAND=$1
    shift

    if [ "$SUBCOMMAND" = "--verbose" ] || [ "$SUBCOMMAND" = "-v" ]; then
        VERBOSE=0;
        if [ $# -eq 0 ]; then
            print_help
            exit 1
        fi
        SUBCOMMAND=$1
        shift
    fi
    if [ "$SUBCOMMAND" = "--dry-run" ] || [ "$SUBCOMMAND" = "-n" ]; then
        DRY_RUN=0
        SUBCOMMAND=$1
        shift
    fi
    if [ "$SUBCOMMAND" = "--help" ] || [ "$SUBCOMMAND" = "-h" ]; then
        print_help
        exit 0
    fi
    if [ "$SUBCOMMAND" = "--version" ]; then
        echo "$VERSION"
        exit 0
    fi

    case "$SUBCOMMAND" in
        add)
            # Parse 'run' specific options
            SUB_TEMP=$(getopt -o r:nflhd: -l link-root:,dry-run,force,links,hooks,directory: -n "run" -- "$@")
            # shellcheck disable=SC2181
            if [ $? -ne 0 ]; then exit 1; fi
            eval set -- "$SUB_TEMP"

            ARG_CAIFS_COLLECTIONS=""
            while true; do
                case "$1" in
                    -l|--links) RUN_HOOKS=1; shift ;;
                    -h|--hooks) RUN_LINKS=1; shift ;;
                    # If directory is specified, override any collection paths and just work with this directory
                    -d|--directory)
                        if [ -n "$ARG_CAIFS_COLLECTIONS" ]; then
                            ARG_CAIFS_COLLECTIONS="${ARG_CAIFS_COLLECTIONS}:$(realpath "$2")"
                        else
                            ARG_CAIFS_COLLECTIONS=$(realpath "$2")
                        fi
                        shift 2
                        ;;
                    -n|--dry-run) DRY_RUN=0; shift ;;
                    -r|--link-root) LINK_ROOT=$(realpath "$2"); shift 2;;
                    -f|--force) RUN_FORCE=0; shift ;;
                    --) shift; break ;;
                    *) break ;;
                esac
            done

            # All directories have been parsed, so override any pre-set CAIFS_COLLECTIONS entries
            if [ -n "$ARG_CAIFS_COLLECTIONS" ]; then
                CAIFS_COLLECTIONS=$ARG_CAIFS_COLLECTIONS
            fi
            RUN_TARGETS="$*"

            log_debug "$RUN_TARGETS"
            if [ -z "$RUN_TARGETS" ]; then
                echo "At least one target is required!"
                exit 1
            fi

            log_debug "$SUBCOMMAND RUN_TARGETS=$RUN_TARGETS | VERBOSE=$VERBOSE RUN_LINKS=$RUN_LINKS RUN_HOOKS=$RUN_HOOKS ROOT_DIRECTORY CAIFS_COLLECTIONS=$CAIFS_COLLECTIONS"
            cmd_add
            ;;
        rm)
            SUB_TEMP=$(getopt -o r:nlhd: -l link-root:,dry-run,links,hooks,directory: -n "rm" -- "$@")
            # shellcheck disable=SC2181
            if [ $? -ne 0 ]; then exit 1; fi
            eval set -- "$SUB_TEMP"

            ARG_CAIFS_COLLECTIONS=""
            while true; do
                case "$1" in
                    -d|--directory)
                        if [ -n "$ARG_CAIFS_COLLECTIONS" ]; then
                            ARG_CAIFS_COLLECTIONS="${ARG_CAIFS_COLLECTIONS}:$(realpath "$2")"
                        else
                            ARG_CAIFS_COLLECTIONS=$(realpath "$2")
                        fi
                        shift 2
                        ;;
                    -l|--links) RUN_HOOKS=1; shift ;;
                    -h|--hooks) RUN_LINKS=1; shift ;;
                    -n|--dry-run) DRY_RUN=0; shift ;;
                    -r|--link-root) LINK_ROOT=$(realpath "$2"); shift 2;;
                    --) shift; break ;;
                    *) break ;;
                esac
            done

            # All directories have been parsed, so override any pre-set CAIFS_COLLECTIONS entries
            if [ -n "$ARG_CAIFS_COLLECTIONS" ]; then
                CAIFS_COLLECTIONS=$ARG_CAIFS_COLLECTIONS
            fi
            RUN_TARGETS="$*"

            log_debug "$SUBCOMMAND CAIFS_COLLECTIONS=$CAIFS_COLLECTIONS RUN_TARGETS=$RUN_TARGETS"
            cmd_remove
            ;;
        status)
            SUB_TEMP=$(getopt -o r:d: -l link-root:,directory: -n "status" -- "$@")
            # shellcheck disable=SC2181
            if [ $? -ne 0 ]; then exit 1; fi
            eval set -- "$SUB_TEMP"

            ARG_CAIFS_COLLECTIONS=""
            while true; do
                case "$1" in
                    -d|--directory)
                        if [ -n "$ARG_CAIFS_COLLECTIONS" ]; then
                            ARG_CAIFS_COLLECTIONS="${ARG_CAIFS_COLLECTIONS}:$(realpath "$2")"
                        else
                            ARG_CAIFS_COLLECTIONS=$(realpath "$2")
                        fi
                        shift 2
                        ;;
                    -r|--link-root) LINK_ROOT=$(realpath "$2"); shift 2;;
                    --) shift; break ;;
                    *) break ;;
                esac
            done

            if [ -n "$ARG_CAIFS_COLLECTIONS" ]; then
                CAIFS_COLLECTIONS=$ARG_CAIFS_COLLECTIONS
            fi

            cmd_status
            ;;
        *)
            echo "Unknown subcommand: $SUBCOMMAND"
            echo ""
            print_help
            exit 1
            ;;
    esac
}


# Run a specific type of hook for a given target.
# The script is sourced to give access to all the caifs runtime variables.
# $1: collection path
# $2: target
# $3: hook type [pre|post|rm]
run_hook() {
    collection_path="$1"
    target=$2
    hook_type=$3
    log_debug "Running ${hook_type}-hook for target '$target' in collection $collection_path"

    if [ -f "$collection_path/$target/$HOOKS_DIR/${hook_type}.sh" ]; then
        TMP_DIR=$(mktemp -d)
        cd "${TMP_DIR}" || exit

        # shellcheck disable=SC1090
        # import the hook script functions
        . "$collection_path/$target/$HOOKS_DIR/${hook_type}.sh"

        run_hook_functions

        cd - || exit
        rm -rf "${TMP_DIR}"
    else
        log_debug "No ${hook_type}-hook found for target '$target'. Ignoring"
    fi
}

# $1: collection path
# $2: The target name to run the hook for
run_remove_hook() {
    run_hook "$@" "rm"
}

# $1: collection path
# $2: The target name to run the hook for
run_pre_hook() {
    run_hook "$@" "pre"
}

# $1: collection path
# $2: The target name to run the hook for
run_post_hook() {
    run_hook "$@" "post"
}


# command handler for running the remove action
# $1: target to action
cmd_remove() {
    log_debug "Removing $RUN_TARGETS from '$CAIFS_COLLECTIONS'"
    collection_paths="$CAIFS_COLLECTIONS"

    while [ -n "$collection_paths" ]; do
        caifs_collection="${collection_paths%%:*}"

        log_debug "Working with $caifs_collection"

        for target in $RUN_TARGETS; do
            log_debug "$target"

            if [ "$RUN_LINKS" -eq 0 ]; then
                remove_target_links "${caifs_collection}" "${target}" "${LINK_ROOT}"
            fi

            if [ "$RUN_HOOKS" -eq 0 ]; then
                run_remove_hook "${caifs_collection}" "$target"
            fi
        done
            # Loop control, get the next path to operate on
        if [ "$caifs_collection" = "$collection_paths" ]; then
            # No more paths available. End the loop
            collection_paths=""
        else
            collection_paths="${collection_paths#*"${caifs_collection}":}"
        fi
    done
}

# Loop over the CAIFS_COLLECTIONS variable, which is colon (:) separated paths to caifs collections
# First target wins, so order in the collection is important.
cmd_add() {
    log_debug "cmd_add: begin with collection_paths '$CAIFS_COLLECTIONS'"

    collection_paths="$CAIFS_COLLECTIONS"

    while [ -n "$collection_paths" ]; do

        caifs_collection="${collection_paths%%:*}"

        log_debug "Working with $caifs_collection"

        for target in $RUN_TARGETS; do
            log_debug "$target"

            if [ "$RUN_HOOKS" -eq 0 ]; then
                run_pre_hook "${caifs_collection}" "$target"
            fi

            if [ "$RUN_LINKS" -eq 0 ]; then
                create_target_links "${caifs_collection}" "${target}" "${LINK_ROOT}"
            fi

            if [ "$RUN_HOOKS" -eq 0 ]; then
                run_post_hook "${caifs_collection}" "$target"
            fi
        done

        # Loop control, get the next path to operate on
        if [ "$caifs_collection" = "$collection_paths" ]; then
            # No more paths available. End the loop
            collection_paths=""
        else
            collection_paths="${collection_paths#*"${caifs_collection}":}"
        fi
    done

    log_debug "cmd_add: end"
}

# Check if a target has any linked files
# $1: collection path
# $2: target name
# $3: link root
# Returns 0 if linked, 1 if not
is_target_linked() {
    collection_path="$1"
    target="$2"
    link_root="$3"
    target_directory="${collection_path}/${target}/${CONFIG_DIR}"

    if [ ! -d "$target_directory" ]; then
        return 1
    fi

    # Check if any config file has a corresponding symlink in link_root
    # shellcheck disable=SC2044
    for config_file in $(find "${target_directory}" \( -type f -o -type l \) -printf "%P\n" 2>/dev/null); do
        dest_link="$link_root/$config_file"
        if [ -L "$dest_link" ]; then
            # Verify the symlink points to our target
            link_target=$(readlink "$dest_link")
            case "$link_target" in
                *"$target_directory"*)
                    return 0
                    ;;
            esac
        fi
    done
    return 1
}

# Display status of all targets in collections
cmd_status() {
    log_debug "cmd_status: CAIFS_COLLECTIONS=$CAIFS_COLLECTIONS LINK_ROOT=$LINK_ROOT"

    collection_paths="$CAIFS_COLLECTIONS"

    # Print header
    printf "%-40s %-20s %s\n" "COLLECTION" "TARGET" "LINKED"
    printf "%-40s %-20s %s\n" "$(printf '%0.s-' $(seq 1 40))" "$(printf '%0.s-' $(seq 1 20))" "------"

    while [ -n "$collection_paths" ]; do
        caifs_collection="${collection_paths%%:*}"
        collection_name=$(basename "$caifs_collection")

        log_debug "Checking collection: $caifs_collection"

        # Find all targets (directories containing a config/ subdirectory)
        if [ -d "$caifs_collection" ]; then
            for target_dir in "$caifs_collection"/*/; do
                [ -d "$target_dir" ] || continue
                target=$(basename "$target_dir")

                # Skip if no config directory
                [ -d "$target_dir/$CONFIG_DIR" ] || continue

                if is_target_linked "$caifs_collection" "$target" "$LINK_ROOT"; then
                    status="yes"
                else
                    status="no"
                fi

                printf "%-40s %-20s %s\n" "$collection_name" "$target" "$status"
            done
        fi

        # Loop control
        if [ "$caifs_collection" = "$collection_paths" ]; then
            collection_paths=""
        else
            collection_paths="${collection_paths#*"${caifs_collection}":}"
        fi
    done
}

main "$@"
